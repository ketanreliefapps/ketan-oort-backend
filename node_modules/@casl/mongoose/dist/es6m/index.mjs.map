{"version":3,"file":"index.mjs","sources":["../../src/mongo.ts","../../src/accessible_records.ts","../../src/accessible_fields.ts"],"sourcesContent":["import { AnyMongoAbility } from '@casl/ability';\nimport { rulesToQuery } from '@casl/ability/extra';\n\nfunction convertToMongoQuery(rule: AnyMongoAbility['rules'][number]) {\n  const conditions = rule.conditions!;\n  return rule.inverted ? { $nor: [conditions] } : conditions;\n}\n\nexport function toMongoQuery<T extends AnyMongoAbility>(\n  ability: T,\n  subjectType: Parameters<T['rulesFor']>[1],\n  action: Parameters<T['rulesFor']>[0] = 'read'\n) {\n  return rulesToQuery(ability, action, subjectType, convertToMongoQuery);\n}\n","import { Normalize, AnyMongoAbility, Generics, ForbiddenError, getDefaultErrorMessage } from '@casl/ability';\nimport type { Schema, DocumentQuery, Model, Document } from 'mongoose';\nimport mongoose from 'mongoose';\nimport { toMongoQuery } from './mongo';\n\nfunction failedQuery(\n  ability: AnyMongoAbility,\n  action: string,\n  modelName: string,\n  query: DocumentQuery<Document, Document>\n) {\n  query.where({ __forbiddenByCasl__: 1 }); // eslint-disable-line\n  const anyQuery: any = query;\n\n  if (typeof anyQuery.pre === 'function') {\n    anyQuery.pre((cb: (error?: Error) => void) => {\n      const error = ForbiddenError.from(ability);\n      error.action = action;\n      error.subjectType = modelName;\n      error.setMessage(getDefaultErrorMessage(error));\n      cb(error);\n    });\n  }\n\n  return query;\n}\n\ntype GetAccessibleRecords<T extends Document> = <U extends AnyMongoAbility>(\n  ability: U,\n  action?: Normalize<Generics<U>['abilities']>[0]\n) => DocumentQuery<T, T>;\n\nfunction accessibleBy<T extends AnyMongoAbility>(\n  this: any,\n  ability: T,\n  action?: Normalize<Generics<T>['abilities']>[0]\n): DocumentQuery<Document, Document> {\n  let modelName: string | undefined = this.modelName;\n\n  if (!modelName) {\n    modelName = 'model' in this ? this.model.modelName : null;\n  }\n\n  if (!modelName) {\n    throw new TypeError('Cannot detect model name to return accessible records');\n  }\n\n  const query = toMongoQuery(ability, modelName, action);\n\n  if (query === null) {\n    return failedQuery(ability, action || 'read', modelName, this.where());\n  }\n\n  return this instanceof mongoose.Query ? this.and([query]) : this.where({ $and: [query] });\n}\n\nexport interface AccessibleRecordModel<T extends Document, K = {}> extends Model<T, K & {\n  accessibleBy: GetAccessibleRecords<T>\n}> {\n  accessibleBy: GetAccessibleRecords<T>\n}\n\nexport function accessibleRecordsPlugin(schema: Schema<any>) {\n  schema.query.accessibleBy = accessibleBy;\n  schema.statics.accessibleBy = accessibleBy;\n}\n","import { wrapArray, Normalize, AnyMongoAbility, Generics } from '@casl/ability';\nimport { permittedFieldsOf, PermittedFieldsOptions } from '@casl/ability/extra';\nimport type { Schema, Model, Document } from 'mongoose';\n\nexport type AccessibleFieldsOptions =\n  {\n    getFields(schema: Schema<Document>): string[]\n  } &\n  ({ only: string | string[] } | { except: string | string[] });\n\nexport const getSchemaPaths: AccessibleFieldsOptions['getFields'] = schema => Object.keys((schema as { paths: object }).paths);\n\nfunction fieldsOf(schema: Schema<Document>, options: Partial<AccessibleFieldsOptions>) {\n  const fields = options.getFields!(schema);\n\n  if (!options || !('except' in options)) {\n    return fields;\n  }\n\n  const excludedFields = wrapArray(options.except);\n  return fields.filter(field => excludedFields.indexOf(field) === -1);\n}\n\ntype GetAccessibleFields<T extends AccessibleFieldsDocument> = <U extends AnyMongoAbility>(\n  this: Model<T> | T,\n  ability: U,\n  action?: Normalize<Generics<U>['abilities']>[0]\n) => string[];\n\nexport interface AccessibleFieldsModel<T extends AccessibleFieldsDocument> extends Model<T> {\n  accessibleFieldsBy: GetAccessibleFields<T>\n}\n\nexport interface AccessibleFieldsDocument extends Document {\n  accessibleFieldsBy: GetAccessibleFields<AccessibleFieldsDocument>\n}\n\nfunction modelFieldsGetter() {\n  let fieldsFrom: PermittedFieldsOptions<AnyMongoAbility>['fieldsFrom'];\n  return (schema: Schema<any>, options: Partial<AccessibleFieldsOptions>) => {\n    if (!fieldsFrom) {\n      const ALL_FIELDS = options && 'only' in options\n        ? wrapArray(options.only as string[])\n        : fieldsOf(schema, options);\n      fieldsFrom = rule => rule.fields || ALL_FIELDS;\n    }\n\n    return fieldsFrom;\n  };\n}\n\nexport function accessibleFieldsPlugin(\n  schema: Schema<any>,\n  rawOptions?: Partial<AccessibleFieldsOptions>\n) {\n  const options = { getFields: getSchemaPaths, ...rawOptions };\n  const fieldsFrom = modelFieldsGetter();\n  type ModelOrDoc = Model<AccessibleFieldsDocument> | AccessibleFieldsDocument;\n\n  function accessibleFieldsBy(this: ModelOrDoc, ability: AnyMongoAbility, action?: string) {\n    const subject = typeof this === 'function' ? this.modelName : this;\n    return permittedFieldsOf(ability, action || 'read', subject, {\n      fieldsFrom: fieldsFrom(schema, options)\n    });\n  }\n\n  schema.statics.accessibleFieldsBy = accessibleFieldsBy;\n  schema.method('accessibleFieldsBy', accessibleFieldsBy);\n}\n"],"names":["convertToMongoQuery","rule","conditions","inverted","$nor","toMongoQuery","ability","subjectType","action","rulesToQuery","failedQuery","modelName","query","where","__forbiddenByCasl__","anyQuery","pre","cb","error","ForbiddenError","from","setMessage","getDefaultErrorMessage","accessibleBy","this","model","TypeError","mongoose","Query","and","$and","accessibleRecordsPlugin","schema","statics","getSchemaPaths","Object","keys","paths","fieldsOf","options","fields","getFields","excludedFields","wrapArray","except","filter","field","indexOf","modelFieldsGetter","fieldsFrom","ALL_FIELDS","only","accessibleFieldsPlugin","rawOptions","accessibleFieldsBy","subject","permittedFieldsOf","method"],"mappings":"4LAGA,SAASA,EAAoBC,SACrBC,EAAaD,EAAKC,kBACjBD,EAAKE,SAAW,CAAEC,KAAM,CAACF,IAAgBA,EAG3C,SAASG,EACdC,EACAC,EACAC,EAAuC,eAEhCC,EAAaH,EAASE,EAAQD,EAAaP,GCRpD,SAASU,EACPJ,EACAE,EACAG,EACAC,GAEAA,EAAMC,MAAM,CAAEC,oBAAqB,UAC7BC,EAAgBH,KAEM,oBAAjBG,EAASC,IAClBD,EAASC,KAAKC,UACNC,EAAQC,EAAeC,KAAKd,GAClCY,EAAMV,OAASA,EACfU,EAAMX,YAAcI,EACpBO,EAAMG,WAAWC,EAAuBJ,IACxCD,EAAGC,aAIAN,EAQT,SAASW,EAEPjB,EACAE,OAEIG,EAAgCa,KAAKb,cAEpCA,EACHA,EAAY,UAAWa,KAAOA,KAAKC,MAAMd,UAAY,SAGlDA,QACG,IAAIe,UAAU,+DAGhBd,EAAQP,EAAaC,EAASK,EAAWH,MAEjC,OAAVI,SACKF,EAAYJ,EAASE,GAAU,OAAQG,EAAWa,KAAKX,gBAGzDW,gBAAgBG,EAASC,MAAQJ,KAAKK,IAAI,CAACjB,IAAUY,KAAKX,MAAM,CAAEiB,KAAM,CAAClB,KAS3E,SAASmB,EAAwBC,GACtCA,EAAOpB,MAAMW,aAAeA,EAC5BS,EAAOC,QAAQV,aAAeA,QCtDnBW,EAAuDF,GAAUG,OAAOC,KAAMJ,EAA6BK,OAExH,SAASC,EAASN,EAA0BO,SACpCC,EAASD,EAAQE,UAAWT,OAE7BO,KAAa,WAAYA,UACrBC,QAGHE,EAAiBC,EAAUJ,EAAQK,eAClCJ,EAAOK,QAAOC,IAA4C,IAAnCJ,EAAeK,QAAQD,KAiBvD,SAASE,QACHC,QACG,CAACjB,EAAqBO,SACtBU,EAAY,OACTC,EAAaX,GAAW,SAAUA,EACpCI,EAAUJ,EAAQY,MAClBb,EAASN,EAAQO,GACrBU,EAAahD,GAAQA,EAAKuC,QAAUU,SAG/BD,GAIJ,SAASG,EACdpB,EACAqB,SAEMd,iBAAYE,UAAWP,GAAmBmB,SAC1CJ,EAAaD,aAGVM,EAAqChD,EAA0BE,SAChE+C,EAA0B,oBAAT/B,KAAsBA,KAAKb,UAAYa,YACvDgC,EAAkBlD,EAASE,GAAU,OAAQ+C,EAAS,CAC3DN,WAAYA,EAAWjB,EAAQO,KAInCP,EAAOC,QAAQqB,mBAAqBA,EACpCtB,EAAOyB,OAAO,qBAAsBH"}